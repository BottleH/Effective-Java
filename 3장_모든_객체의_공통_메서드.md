## 3장 모든 객체의 공통 메서드
___
Object에서 final이 아닌 메소드(equals, hashCode, toString, clone, finalize)는 모두 재정의를 염두에 두고 설계되었다. 
이 메소드들을 잘못 구현하면 대상 클래스가 일반적인 규약을 준수한다고 가정하고 만들어진 클래스(HashMap, HashSet 등)에서 
오동작이 일어날 수 있다.

### 아이템10 - equals는 일반 규약을 지켜 재정의하라  
___
equals 메소드 재정의는 쉽지만 위험할 수 있다.
#### 10-1. 재정의하지 않을 상황
  - 각 인스턴스가 본질적으로 고유하다. 
    - 주로 값(VO)을 표현하는게 아니라 동작하는 것을 표현하는 클래스 
  - 인스턴스의 논리적 동치성을 검사할 일이 없다. 
    - regex.Pattern에서 eqauls을 재정의해서 정규표현식이 같은지 재정의하지는 않는다. 
  - 상위 클래스에서 재정의한 equals가 하위 클래스에서도 같은 상황이다.
  - 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.

#### 10-2. 재정의해야 할 상황
  - '메모리주소를 기반으로 물리적으로 같은가?' 가 아니라 논리적 동치성(logical equality)를 비교해야할 때
    - 즉, 객체가 같은지가 중요한게 아니라, 객체 내 값이 같은지 비교해야할 때 재정의해야한다.
  - Map의 키, Set의 원소 등으로 사용할 때
## 5장 제네릭

제네릭은 jdk1.5 부터 사용할 수 있다. 제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때 마다 형변환을 해야 했다. 
1.5 부터는 제네릭을 사용하면 컬렉션에 담을 수 있는 타입을 컴파일러에게 알려주며, 컴파일러가 알아서 형변환 코드를 추가한다. 
또한 엉뚱한 객체를 넣는 코드가 있다면 컴파일 타임에 차단해준다.

### 아이템26 - 로 타입은 사용하지 말라  
___
#### 26-1. raw Type의 정의
클래스와 인터페이스 선언에 타입 매개변수(ex. ```<E>```)가 있으면 각각 제네릭 클래스, 제네릭 인터페이스라고 부른다. 
이것을 제네릭 타입이라고 한다. (ex. ```List<E>```) 제네릭 타입을 정의하면 raw type도 정의되는데, 
여기서 ```List<E>```의 raw type이란 List 이다. 즉, 
__타입 매개변수를 쓰지 않은 경우__
를 말한다. 
이는 제네릭이 도입되기 전의 코드들의 호환성을 위한 것이다.

#### 26-2. 로 타입 비추천 예시
```java
// Stamp 인스턴스만 취급
private final Collection stamps = ...;
// 실수로 동전을 넣는다.
stamps.add(new Coin(...)); // "unchecked call" 경고를 내뱉는다.
```
오류의 발견은 컴파일 타임에 되는게 가장 이상적이다. raw type을 사용할 경우, unchecked 경고가 나오며, 
잘못된 타입을 add할 수도 있다. 위의 예시는 런타임에서 문제가 생길 것이다. (ClassCastException 등)  
따라서 raw type을 쓰지말고, 제네릭 타입을 쓴다면 컴파일러의 검사력(정적언어의 장점을 활용)과 타입 불변, 안정성을 
얻을 수 있다.
 - 자바와 같은 JVM언어 중에 코틀린은 제네릭을 쓰지 않으면 컬렉션을 쓰지 못하도록 아예 막아버렸다. 
   자바는 하위호환성 때문에 쓰지말라고 권고만 함
```java
private final Collection<Stamp> stamps = ...;
```
위와 같이 매개변수화된 컬렉션 타입을 이용해 안전성을 확보하자.
#### 26-3. 로 타입 / 와일드카드(```<?>```) / ```<Object>```
```java
List rawList = new ArrayList<String>(); // 런타임에는 아무런 타입이 남지 않기때문에 컴파일 성공
List<?> wildList = new ArrayList<String>(); // 컴파일 성공
List<Object> genericList = new ArrayList<String>(); // 컴파일 실패
```
만약 타입 매개변수를 신경쓰지 않고 쓰고싶다해도 raw type보단 제네릭의 와일드카드를 쓰는 것이 좋다. (ex. ```Set<?>```)
이렇게 하면 어떤 타입도 받을 수 있으면서 안전하며 유연해진다.  
raw type과 와일드카드의 차이점은 raw type은 안전하지 않고, 와일드카드는 안전하다는 것이다.  
 - raw type 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다.

와일드카드와 ```<Object>```의 차이는 구체적 인스턴스의 차이인데, 와일드카드는 제네릭 타입 매개변수에 의존성이 있는 
코드가 있다면 컴파일러가 실패처리한다. ```<Object>```는 내부에서 또 다시 형 변환해야하므로 코드가 좀 더 복잡해지며,
제네릭의 장점이 사라진다.

#### 26-4. 로 타입을 쓰는 예외
 -  class 리터럴은 raw type으로 써야한다.
    - ```List.class``` 는 되지만, ```List<String>.class```, ```List<?>.class``` 은 허용되지 않는다.
     
```java
if (o instanceof Set){
    Set<?> s = (Set<?>) o;
    ...
    }   
```
 - instanceof 연산자는 런타임에서 타입을 비교한다. 제네릭 타입은 런타임에서 소거되므로 제네릭 타입으로 
   비교할 수 없다.
    - o의 타입이 Set임을 확인한 다음 와일드카드 타입인 Set<?>로 형변환해야 한다.

### 아이템27 - 비검사 경고를 제거하라
___
비검사 경고(ex. `warning: [unchecked] unchecked ...`)를 제거할수록 타입 안정성이 높아진다고 볼 수 있다.

#### 27-1. `@SuppressWarnings("unchecked")` 사용하기
경고를 제거할 수는 없지만 타입이 안전하다고 확신할 수 있다면 ```@SuppressWarnings("unchecked")```
애너테이션을 달아 경고를 숨기자
 - 반드시 가능한 한 좁은 범위에 적용 => 자칫 심각한 경고를 놓칠 수 있음.
 - 해당 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 한다.

> 결론: 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성을 뜻하니 최선을 다해 제거하라.
> - ClassCastException - 객체 타입변환이 적절하지 않을 때 발생함. 

### 아이템28 - 배열보다는 리스트를 사용하라
___
#### 28-1. 배열과 리스트의 차이
 - 배열: 공변(함께 변함)이다.
    - ex) Sub가 Super의 하위타입이면, 배열 ```Sub[]```는 배열 ```Super[]```의 하위 타입이다.
 - 리스트: 불공변이다.
    - ex) 서로다른 Type1, Type2가 있을 때, ```List<Type1>```과 ```List<Type2>```는 관계가 없다.

```java
/* 문법상 허용되는 코드 - 런타임에 실패한다 */
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다."; //ArrayStoreException을 던진다.

/* 문법상 허용되지 않는 코드 - 컴파일에 실패한다 */
List<Object> ol = new ArrayList<Long>(); // 호환되지 않는
```
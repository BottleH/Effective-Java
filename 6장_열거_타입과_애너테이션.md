## 6장 열거 타입과 애너테이션

자바에는 특수한 목적의 참조타입이 2가지가 있다.

- 클래스의 일종인 __열거타입__
- 인터페이스의 일종인 __애너테이션__

### 아이템34 - int 상수 대신 열거 타입을 사용하라

___

#### 34-1. 정수 열거 패턴

열거 타입이 등장하기 전에는 아래와 같은 정수 열거 패턴을 사용했다.

```text
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;

public static final int ORANGE_NAVEL = 0;
public static final int ORANGE_TEMPLE = 1;
```

__정수 열거 패턴의 단점__

1. 타입 안전을 보장할 수 없다.

    - 오렌지를 건네야 하는 메서드에 사과를 보내고, 동등 연산자(`==`)로 비교해도 아무런 경고없이 동작함.

2. 표현력이 좋지 않다.

    - 사과용 상수와 오렌지용 상수의 이름 충돌을 방지하기 위해 어쩔 수 없이 접두사(prefix)를 사용함.

3. 정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다.

    - 상수의 값이 바뀌면 클라이언트도 반드시 다시 컴파일 해야한다.

4. 정수 상수는 문자열로 출력하기가 다소 까다롭다.

❗ 문자열 열거 패턴: 정수 열거 패턴보다 더욱 좋지 않음. 프로그래머가 하드코딩하게 만들기 때문

#### 34-2. 열거 타입

```java
public enum Apple {
    FUJI, PIPPIN, GRANNY_SMITH
}

public enum Orange {
    NAVEL, TEMPLE, BLOOD
}
```

__열거 타입의 장점__

1. 자바의 열거 타입은 완전한 형태의 클래스라고 볼 수 있다.
2. 열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 `final` 이다.
    - 따라서 인스턴스들은 오직 하나만 존재함이 보장됨.
3. 열거 타입은 컴파일 타임에서의 타입 안전성을 제공함.
    - Apple 열거 타입을 매개변수로 받는 메서드를 선언했다면, 건네받은 참조는 Apple의 세 가지 값 중 하나임이 확실함. 다른 타입의 값을 넘기려 하면 컴파일 오류가 발생한다.
4. 열거 타입의 toString 메서드는 출력하기에 적합한 문자열을 제공한다.
    - 임의의 메서드나 필드를 추가할 수 있고 임의의 인터페이스를 구현하게 할 수 있다.

__열거 타입의 좋은 예시__

```java
enum Planet {
    MERCURY(3.302e+23, 2.439e6),
    VENUS(4.869e+24, 6.052e6),
    EARTH(5.975e+24, 6.378e6);
    // ...

    private final double mass; // 질량
    private final double radius; // 반지름
    private final double surfaceGravity; // 표면중력

    // 중력상수
    private static final double G = 6.67300E-11;

    // 생성자
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        surfaceGravity = G * mass / (radius * radius);
    }

    public double mass() {
        return mass;
    }

    public double radius() {
        return radius;
    }

    public double surfaceGravity() {
        return surfaceGravity;
    }

    public double surfaceWeight(double mass) {
        return mass * surfaceGravity; // F = ma
    }
}
```

열거 타입은 근본적으로 불변이므로 모든 필드는 final 이어야 한다.

#### 34-3. 상수별 메소드 구현(constant_specific method implementation)

상수가 더 다양한 기능을 제공하길 원해서 아래와 같이 코딩을 해보았다고 가정하자.

```java
enum Operation {
    PLUS, MINUS, TIMES, DIVIDE;

    public double apply(double x, double y) {
        switch (this) {
            case PLUS:
                return x + y;
            case MINUS:
                return x - y;
            case TIMES:
                return x * y;
            case DIVIDE:
                return x / y;
        }
        throw new AssertionError("알 수 없는 연산: " + this);
    }
}
```

위 예시의 가장 안 좋은 점은 깨지기 쉬운 코드라는 점이다.

- ex) 새로운 상수를 추가하려면 case 문을 추가해야 함.

상수별 메소드 구현의 예시

```java
enum Operation {
    PLUS {
        public double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS {
        public double apply(double x, double y) {
            return x - y;
        }
    };

    public abstract double apply(double x, double y);
}
```

위와 같은 상수별 메서드 구현(constant-specific method implementation)은 상수에서 자신에 맞게 재정의하는 것을 말한다.

> 책에서는 apply 메서드가 상수 선언 바로 밑에 있으니 새로운 상수를 추가할 때도 apply 메서드를 항상 재정의해야 한다는 사실을 까먹기 어렵다고 한다.. 나는 썩 공감가지는 않았다.

apply 메서드가 추상 메서드이므로 재정의하지 않았다면 컴파일 오류도 알려준다. 첫번째 예시는 런타임 오류로 알려줌!

__상수별 메서드 구현의 단점__

- 열거 타입 상수끼리 코드를 공유하기가 어려운 점

#### 34-4. 전략 열거 타입 패턴

switch 문이나 상수별 메서드 구현이 필요 없음. 새로운 상수를 추가할 때마다 전략을 선택하도록 하는 것

```java
enum PayrollDay {
    MONDAY(), TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,
    SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);

    private final PayType payType;

    PayrollDay() {
        this(PayType.WEEKDAY);
    }

    PayrollDay(PayType payType) {
        this.payType = payType;
    }

    enum PayType {
        WEEKDAY {
            int overtimePay(int minsWorked, int payRate) {
                int overtimePay;
                if (minsWorked <= MINS_PER_SHIFT) {
                    overtimePay = 0;
                } else {
                    overtimePay = (minsWorked - MINS_PER_SHIFT) * payRate / 2;
                }
                return overtimePay;
            }
        },
        WEEKEND {
            int overtimePay(int minsWorked, int payRate) {
                return minsWorked * payRate / 2;
            }
        };

        abstract int overtimePay(int mins, int payRate);

        private static final int MINS_PER_SHIFT = 8 * 60; // 하루 8시간

        int pay(int minutesWorked, int payRate) {
            int basePay = minutesWorked * payRate;
            return basePay + overtimePay(minutesWorked, payRate);
        }
    }
}
```

> 결론: 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자. 또한, 열거 타입에 정의된 상수 개수가 영원히 고정불변일 필요는 없다.

### 아이템 35 - `ordinal` 메서드 대신 인스턴스 필드를 사용하라

___
모든 열거 타입은 해당 상수가 열거 타입에서 몇 번째인지 반환하는 ordinal 메서드를 제공한다.

#### 35-1. `ordinal` 메소드 사용 시 주의사항

__`ordinal`을 잘못 사용한 예시__

```java
public enum Ensemble {
    SOLO, DUET, TRIO, QUARTET, QUINTET,
    SEXTET, SEPTET, OCTET, NONET, DECTET;

    public int numberOfMusicians() {
        return ordinal() + 1;
    }
}
```

동작은 하지만 유지보수가 매우 힘들다.

- 상수 선언 순서가 바뀌는 순간 오동작
- 이미 사용 중인 정수와 값이 같은 상수는 추가할 방법이 없음.
- 값을 중간에 비워둘 수도 없다.

✔ __해결책__

```java
public enum Ensemble {
    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),
    SEXTET(6), SEPTET(7), OCTET(8), NONET(9), DECTET(10),
    DOUBLE_QUARTET(8), TRIPLE_QUARTET(12);

    private final int numberOfMusicians;

    Ensemble(int size) {
        this.numberOfMusicians = size;
    }

    public int numberOfMusicians() {
        return numberOfMusicians;
    }
}
```

위와 같이 열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지 말고, 인스턴스 필드에 저장해서 사용하면 된다.

> 결론: ordinal 메서드는 열거 타입 기반의 범용 자료구조에 쓸 목적으로 설계되었다. 따라서, 이런 용도가 아니라면 ordinal 메서드는 절대 사용하지 말자.

### 아이템 36 - 비트 필드 대신 `EnumSet`을 사용하라

___

#### 36-1. 비트 필드의 단점

열거한 값들이 주로 (단독이 아닌) 집합으로 사용될 경우, 아래와 같이 비트 필드 표현을 사용했다.

```java
public class Text {
    public static final int STYLE_BOLD = 1 << 0;  // 1
    public static final int STYLE_ITALIC = 1 << 1;  // 2
    public static final int STYLE_UNDERLINE = 1 << 2;  // 4
    public static final int STYLE_STRIKETHROUGH = 1 << 3; // 8

    // 매개변수 styles는 0개 이상의 STYLE_ 상수를 비트별 OR한 값이다.
    public void applyStyles(int styles) {
        // ...
    }
}
```

다음과 같이 비트별 OR를 이용하여 여러 상수를 하나의 집합으로 모을 수 있었는데 이를 비트 필드(bit field)라고 한다.

```text
text.applyStyles(STYLE_BOLD | STYLE_ITALIC);
```

__비트 필드의 단점__

1. 정수 열거 상수의 단점을 그대로 지닌다..
2. 정수 열거 상수보다 해석하기 훨씬 어렵다.
3. 비트 필드 하나에 녹아 있는 모든 원소를 순회하기도 까다롭다.
4. 최대 몇 비트가 필요한지를 API 작성 시 미리 예측하여 적절한 타입을 선택해야 한다.

#### 36-2. `EnumSet`

`EnumSet` 클래스는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해준다.

__`EnumSet`의 장점__

1. Set 인터페이스를 구현하며 타입 안전하고 다른 어떤 Set 구현체와도 함께 사용할 수 있다.
2. `EnumSet`의 내부는 비트 벡터로 구현되었기 때문에 원소가 64개 이하라면, EnumSet 전체를 long 변수 하나로 표현한다.
3. `removeAll`과 `retainAll`과 메서드는 비트 필드를 쓸 때와 동일하게 비트를 효율적으로 처리할 수 있는 산술 연산을 사용하여 구현했다.
4. 비트를 직접 다룰 때의 발생할 수 있는 오류에서 자유롭다.

```java
public class Text {
    public enum Style {BOLD, ITALIC, INDERLINE, STRIKETHROUGH}

    // 깔끔하고 안전하다. 어떤 Set을 넘겨도 되나, EnumSet이 가장 좋다.
    // 보통 인터페이스를 전달 받는 것이 좋은 습관이다.
    public void applyStyles(Set<Style> styles) {
        // ...
    }
}
```

__`EnumSet`의 단점__

1. 불변 `EnumSet`을 만들 수 없다.
    - 자바 11버전까지 추가가 안되었음.
    - `Collections.unmodifiableSet`을 사용하면 불변 상태로 만들 수 있다.

> 결론: 비트 필드를 사용할 이유가 없다. `EnumSet`을 사용하자.


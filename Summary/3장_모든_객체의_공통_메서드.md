## 3장 모든 객체의 공통 메서드
Object에서 final이 아닌 메소드(equals, hashCode, toString, clone, finalize)는 모두 재정의를 염두에 두고 설계되었다. 
이 메소드들을 잘못 구현하면 대상 클래스가 일반적인 규약을 준수한다고 가정하고 만들어진 클래스(HashMap, HashSet 등)에서 
오동작이 일어날 수 있다.

### 아이템10 - equals는 일반 규약을 지켜 재정의하라  
___
equals 메소드 재정의는 쉽지만 위험할 수 있다.
#### 10-1. 재정의하지 않을 상황
  - 각 인스턴스가 본질적으로 고유하다. 
    - 주로 값(VO)을 표현하는게 아니라 동작하는 것을 표현하는 클래스 
  - 인스턴스의 논리적 동치성을 검사할 일이 없다. 
    - `java.util.regex.Pattern`에서 eqauls을 재정의해서 정규표현식이 같은지 재정의하지는 않는다. 
  - 상위 클래스에서 재정의한 equals가 하위 클래스에서도 같은 상황이다.
  - 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
      - 철저히 회피하고 싶으면 아래와 같이 구현해두자.

```java
@Override public boolean equals(Object o){
    throw new AssertionError(); // 호출금지!!
}
```



#### 10-2. 재정의해야 할 상황
  - '메모리주소를 기반으로 물리적으로 같은가?' 가 아니라 논리적 동치성(logical equality)를 비교해야할 때
    - 즉, 객체가 같은지가 중요한게 아니라, 객체 내 값이 같은지 비교해야할 때 재정의해야한다.
    - 주로 값 클래스(`Integer`, `String`)

#### 10-3. equals 일반규약

equals 메서드를 재정의할 때는 반드시 일반 규약을 따라야 한다.

- **반사성**: null이 아닌 모든 참조 값 x에 대해, `x.equals(x)`는 true다.
  - 객체는 자기 자신과 같아야 한다는 뜻

- **대칭성**: null이 아닌 모든 참조 값 x, y에 대해, `x.equals(y)`가 true면 `y.equals(x)`도 true다.
  - 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.

```java
public class CaseInsensitiveString {
    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    }
    
    // 대칭성 위배!
    @Override
    public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString) {
            return s.equalsIgnoreCase(
                    ((CaseInsensitiveString) o).s);
        } else if (o instanceof String) { // 한 방향으로만 작동한다!
            return s.equalsIgnoreCase((String) o);
        }
        return false;
    }
}
```

여기서 `String.eqauls(CaseInsensitiveString)`은 실패하여 대칭성을 위배한다.

- **추이성**: null이 아닌 모든 참조 값 x, y, z에 대해, `x.equals(y)`가 true이고 `y.equals(z)`도 true면, `x.equals(z)`도 true다.
  - 개인적인 견해로는 삼단논법을 생각하면 된다!

- **일관성**: null이 아닌 모든 참조 값 x, y에 대해, `x.equals(y)`를 반복해서 호출하면 항상 true를 반환하거나, 항상 false를 반환한다.

- **null-아님**: null이 아닌 모든 참조 값 x에 대해, `x.equals(null)`은 false다.


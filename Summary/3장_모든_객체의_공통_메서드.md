## 3장 모든 객체의 공통 메서드
Object에서 final이 아닌 메소드(equals, hashCode, toString, clone, finalize)는 모두 재정의를 염두에 두고 설계되었다. 
이 메소드들을 잘못 구현하면 대상 클래스가 일반적인 규약을 준수한다고 가정하고 만들어진 클래스(HashMap, HashSet 등)에서 
오동작이 일어날 수 있다.

### 아이템10 - equals는 일반 규약을 지켜 재정의하라  
___
equals 메소드 재정의는 쉽지만 위험할 수 있다.
#### 10-1. 재정의하지 않을 상황
  - 각 인스턴스가 본질적으로 고유하다. 
    - 주로 값(VO)을 표현하는게 아니라 동작하는 것을 표현하는 클래스 
  - 인스턴스의 논리적 동치성을 검사할 일이 없다. 
    - `java.util.regex.Pattern`에서 eqauls을 재정의해서 정규표현식이 같은지 재정의하지는 않는다. 
  - 상위 클래스에서 재정의한 equals가 하위 클래스에서도 같은 상황이다.
  - 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
      - 철저히 회피하고 싶으면 아래와 같이 구현해두자.

```java
@Override public boolean equals(Object o){
    throw new AssertionError(); // 호출금지!!
}
```



#### 10-2. 재정의해야 할 상황
  - '메모리주소를 기반으로 물리적으로 같은가?' 가 아니라 논리적 동치성(logical equality)를 비교해야할 때
    - 즉, 객체가 같은지가 중요한게 아니라, 객체 내 값이 같은지 비교해야할 때 재정의해야한다.
    - 주로 값 클래스(`Integer`, `String`)

#### 10-3. equals 일반규약

equals 메서드를 재정의할 때는 반드시 일반 규약을 따라야 한다.

##### 10-3-1. **반사성**

- null이 아닌 모든 참조 값 x에 대해, `x.equals(x)`는 true다.
- 객체는 자기 자신과 같아야 한다는 뜻

##### 10-3-2. **대칭성** 

- null이 아닌 모든 참조 값 x, y에 대해, `x.equals(y)`가 true면 `y.equals(x)`도 true다.
- 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.

```java
public class CaseInsensitiveString {
    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    }
    
    // 대칭성 위배!
    @Override
    public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString) {
            return s.equalsIgnoreCase(
                    ((CaseInsensitiveString) o).s);
        } else if (o instanceof String) { // 한 방향으로만 작동한다!
            return s.equalsIgnoreCase((String) o);
        }
        return false;
    }
}
```

여기서 `String.eqauls(CaseInsensitiveString)`은 실패하여 대칭성을 위배한다.

##### 10-3-3. **추이성**

- null이 아닌 모든 참조 값 x, y, z에 대해, `x.equals(y)`가 true이고 `y.equals(z)`도 true면, `x.equals(z)`도 true다.
- 개인적인 견해로는 삼단논법을 생각하면 된다!

```java
public class Point {
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public boolean equals(Object o) {
        if (!(o instanceof Point)) {
            return false;
        }
        Point p = (Point) o;
        return p.x == x && p.y == y;
    }
}

public class ColorPoint extends Point {
    private Color color;

    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    public boolean equals(Object o) {
        if (!(o instanceof Point)) {
            return false;
        } else if (!(o instanceof ColorPoint)) {
            return o.equals(this);
        }
        return super.equals(o) && ((ColorPoint) o).color == color;
    }
}
```

위 코드는 색상을 무시하고 비교하게 된다.

**구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.**

상속대신 **컴포지션**으로 우회하는 방법이 있다.

- Point를 상속하는 대신 ColorPoint의 private 필드로 두자.

✔ 리스코프 치환 원칙에 따르면, 어떤 타입에 있어 중요한 속성이라면 그 하위 타입에서도 마찬가지로 중요하다. 즉, 그 타입의 모든 메서드가 하위 타입에서도 똑같이 잘 작동해야 한다.

##### 10-3-4. **일관성**

- null이 아닌 모든 참조 값 x, y에 대해, `x.equals(y)`를 반복해서 호출하면 항상 true를 반환하거나, 항상 false를 반환한다.
- 두 객체가 같다면 (어느 하나 혹은 두 객체 모두가 수정되지 않는 한) 앞으로도 영원히 같아야 한다는 뜻
- 클래스를 작성할 때는 불변 클래스로 만드는 게 나을지를 심사숙고 하자.
- 클래스가 불변이든 가변이든 **equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.**

##### 10-3-5. **null-아님**

- null이 아닌 모든 참조 값 x에 대해, `x.equals(null)`은 false다.




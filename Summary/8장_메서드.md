## 8장 메서드

이번 장의 내용 중 상당부분은 메서드뿐 아니라 생성자에도 적용된다.

### 아이템49 - 매개변수가 유효한지 검사하라

___
매개변수 검사를 제대로 하지 못하는 경우 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다. 더 나쁜 상황은 메서드가 잘 수행되지만 잘못된 결과를 반환할 때다. 더더욱 나쁜 상황은 메서드는 문제없이
수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼 때다.

#### 49-1. 문서화

`public`과 `protected` 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.(`@throws` 자바독 태그 사용) 클래스 수준 주석은 그 클래스의 모든 public 메서드에 적용되므로
각 메서드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다.

✔ `@Nullable`이나 이와 비슷한 애너테이션을 사용해 특정 매개변수는 null이 될 수 있다고 알려줄 수도 있지만, 표준적인 방법은 아니다.

#### 49-2. 유효성검사 방법

1. 자바 7에 추가된 `java.util.Objects.requireNonNull`

```text
this.strategy=Objects.requireNonNull(strategy,"전략");
```

더이상 null 검사를 수동으로 하지 않아도 되며, 유연하다.

2. 자바 9에서 추가된 `Objects`에 범위 검사 기능

`checkFromIndexSize`, `checkFromToIndex`, `checkIndex` 라는 메서드인데 null 검사 메서드만큼 유연하지는 않다. 예외 메시지를 지정할 수 없고 리스트와 배열 전용으로
설계됐다. 또한, 닫힌 범위(양 끝단 값을 포함하는)는 다루지 못한다.

3. `assert`

공개되지 않은 메서드(`private`)라면 개발자가 직접 호출되는 상황을 통제할 수 있다. 따라서 오직 유효한 값만이 메서드에 넘겨지리라는 것을 여러분이 보증할 수 있고, 그렇게 해야 한다. 즉, 이럴
때는 `assert`를 사용하여 매개변수 유효성을 검사할 수 있다.

```text
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >=0 && offset <= a.length;
    ...// 계산수행
}
```

여기서 핵심은 위의 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다.

단언문은 몇 가지 면에서 일반적인 유효성 검사와 다르다.

- 실패하면 `AssertionError`를 던진다.
- 런타임에 아무런 효과도, 아무런 성능 저하도 없다.
    - 단, `-ea`, `--enableassertions` 플래그 설정하면 런타임에 영향을 줌.

#### 49-3. 유효성검사 예외

1. 유효성검사 비용이 지나치게 높을 때
2. 실용적이지 않을 때
3. 계산과정에서 암묵적으로 검사가 수행될 때

✔ 예를 들어, `Collections.sort(List)`처럼 리스트를 정렬할 때는 정렬 과정에서 모든 객체가 상호 비교된다. 만일 비교할 수 없는 타입의 객체가 있으면 `ClassCastException`이
발생할 것이기 때문에 비교하기에 앞서 모든 원소를 검증하는 것은 불필요한 과정이 된다.

> 결론: 아이템49를 "매개변수에 제약을 두는 게 좋다"고 해석해서는 안 된다. 사실은 그 반대다. 메서드는 최대한 범용적으로 설계해야 한다.

### 아이템50 - 적시에 방어적 복사본을 만들라

___
자바는 네이티브(Native) 메서드를 사용하지 않아서 C, C++ 언어에서의 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전하다. 하지만 다른 클래스로부터의 침범을 아무런 노력없이 다
막을 수 있는 건 아니다. 따라서 클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.

#### 50-1. 불변식을 지키지 못하는 경우

```java
public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        }
        this.start = start;
        this.end = end;
    }

    public Date start() {
        return start;
    }

    public Date end() {
        return end;
    }
    // ... 생략
}
```

위 클래스는 불변처럼 보인다. 하지만 Date가 가변이라는 사실을 이용하면 어렵지 않게 불변을 깨뜨릴 수 있다.

다행히 자바8 이후로는 쉽게 해결할 수 있다. Date 대신 불변인 Instant를 사용하자.(혹은 `LocalDateTime`, `ZonedDateTime` 사용) **Date는 낡은 API이니 새로운 코드를
작성할 때는 더 이상 사용하면 안 된다.**
하지만 Date처럼 가변인 낡은 타입을 쓰던 시절이 길어서 예전에 작성된 낡은 코드들을 대처해보자.

#### 50-2. 방어적 복사

위의 Period 인스턴스의 내부를 보호하려면 외부의 공격으로부터 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수를 방어적으로 복사해

```java
public Period(Date start,Date end){
        this.start=new Date(start.getTime());
        this.end=new Date(end.getTime());

        if(start.compareTo(this.end)>0){
        throw new IllegalArgumentException(start+"가 "+end+"보다 늦다.");
        }
        }
```

위와 같이 매개변수의 유효성을 검사하기 전에 복사본을 만들어야 한다. 멀티 스레드(Multi-Thread) 환경이라면 원본 객체의 유효성을 검사한 후에 복사본을 만드는 찰나의 순간에 다른 스레드가 원본 객체를 수정할
가능성이 있기 때문이다.

❗ 이와 같은 공격을 검사시점 / 사용시점(time-of-check / time-of-use) 공격 혹은 TOCTOU 공격이라고 한다.

##### 50-2-1. 방어적 복사에서의 `clone`

매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다. 생성자에서와 다르게 접근자 메서드에서는 clone 메서드를 사용해도 된다. Date 객체가 반환될 것임이
확실하기 때문!

##### 50-2-2. 접근자 메서드

위의 Period 메서드는 접근자(getter) 메서드가 내부의 가변 정보 직접 드러내기 때문에 공격이 가능하다.

```text
    Date start=new Date();
    Date end=new Date();
    Period p=new Period(start,end);
    p.end().setYear(78);
```

이 공격을 막아내려면 **가변 필드의 방어적 복사본을 반환하면 된다.**

```text
public Date start(){
    return new Date(start.getTime());
    }
public Date end(){
    return new Date(end.getTime());
    }
```

방어적 복사는 성능 저하가 있을 수 있고 같은 패키지에 속하는 등의 이유로 클라이언트가 객체의 상태를 변경하지 않는 것이 확실하다면 방어적 복사본을 만들지 않아도 된다. 하지만 이러한 상황이라도 명확히 문서화하는
것이 좋다. 다른 패키지에서 사용한다고 해서 방어적 복사를 항상해야 하는 것도 아니다. 메서드 또는 생성자의 매개변수로 넘기는 행위 자체의 의미가 그 객체의 통제권을 명백히 이전함을 뜻하기도 한다.

> 결론: 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다. 되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다.

### 아이템51- 메서드 시그니처를 신중히 설계하라

___

1. **메서드 이름은 신중히 짓자.**
    - 표쥰 명명 규칙에 따라야 한다.
    - 같은 패키지에 속한 다른 이름들과 일관되게 짓는 게 최우선 목표다.
    - 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용하자.
    - 긴 이름은 피하자.
    - 애매하면 자바 라이브러리의 API 가이드를 참조하라.

2. **편의 메서드를 너무 많이 만들지 말자.**
    - 너무 많은 메서드는 그에 따른 문서화, 유지보수, 테스트를 요구한다.
    - 아주 자주 쓰일 경우에만 별도의 약칭 메서드를 두기 바란다.
    - 확신이 서지 않으면 만들지 말자.

3. **매개변수 목록은 짧게 유지하자.**
    - 4개 이하가 좋다.(4개 이상은 매개변수를 전부 기억하기가 쉽지 않다.)
    - 같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭다.
        - 매개변수 순서를 기억하기 어렵고, 바꿔 입력해서 컴파일되고 실행된다.

4. **매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다.**
    - 예를 들어 `HashMap` 보다는 `Map`을 사용하는 편이 좋다.
    - 클래스를 사용하는 것은 클라이언트에게 특정 구현체만 사용하도록 제한하는 것이다.

5. **`boolean` 보다는 원소 2개짜리 `enum`이 더 낫다.**
    - 메서드 이름상 `boolean`을 받아야 의미가 더 명확할 때는 예외다.
    - 열거 타입을 사용하면 코드를 읽고 쓰기가 더 쉬워지며, 나중에 선택지를 추가하기도 쉽다.

#### 51-1. 매개변수 목록을 짧게 줄여주는 기술

##### 51-1-1. 여러 메서드로 쪼갠다.

잘못하면 메서드가 너무 많아질 수 있지만 *직교성*을 높여 오히려 메서드 수를 줄여주는 효과도 있다.

ex) 리스트에서 특정 요소를 찾는다고 가정해보자. 이 기능을 하나의 메서드로 구현하려면 리스트의 시작과 끝 그리고 찾을 요소까지 총 3개의 매개변수가 필요하다. 하지만 List 인터페이스는 `subList`
와 `indexOf` 메서드를 별개로 제공한다.

✔ 직교성: 소프트웨어적 관점에서의 직교성은 "공통점이 없는 기능들이 잘 분리되어 있다", "기능을 원자적으로 쪼개 제공한다."라는 뜻

##### 51-1-2. 매개변수 여러 개를 묶어주는 도우미 클래스를 만들기

일반적으로 이런 도우미 클래스는 정적 멤버 클래스로 둔다.

##### 51-1-3. 빌더 패턴

이 기법은 매개변수가 많을 때, 특히 그중 일부는 생략해도 괜찮을 때 도움이 된다.

### 아이템52 - 다중정의는 신중히 사용하라

___
다중 정의(overloading, 오버로딩)된 메서드의 호출 여부는 컴파일 타임에 정해진다.

#### 52-1. 다중정의 예시

```java
class ColectionClassifier {
    public static String classify(Set<?> set) {
        return "집합";
    }

    public static String classify(List<?> list) {
        return "리스트";
    }

    public static String classify(Collection<?> collection) {
        return "그 외"
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {
                new HashSet<String>(),
                new ArrayList<Integer>(),
                new HashMap<String, String>().values()
        };

        for (Collection<?> c : collections) {
            System.out.println(classfy(c));
        }
    }
}
```

위 코드의 실제 출력 결과는 “그 외” 만 연달아 세 번 출력한다. 그 이유는 세 classify 중 어느 메서드를 호출할지가 컴파일 타임에 정해지기 때문이다. 컴파일 타임에서는 for 문 안의 c는
항상 `Collection<?>` 타입이다.

이처럼 직관과 어긋나는 이유는 **재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택되기 때문이다.**
만약 위 예시가 재정의가 되었다면 생각한대로 출력이 되었을 것이다. 반면, 다중정의된 메서드 사이에서는 객체의 런타임 타입은 전혀 중요치 않다. 선택은 컴파일타임에, 오직 매개변수의 컴파일타임 타입에 의해 이뤄진다.

#### 52-2. 다중정의를 사용할 때 규칙

1. 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.
2. 가변인수(varargs)를 사용하는 메서드라면 다중정의를 아예 하지 말아야 한다.
3. 메서드를 다중정의할 때, 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안된다.
    - 서로 다른 함수형 인터페이스라도 서로 근본적으로 다르지 않다는 뜻이다.

✔ 다중정의하는 대신 메서드 이름을 다르게 지어주는 길도 항상 열려 있다.

### 아이템53 - 가변인수는 신중히 사용하라

___
가변인수 메서드를 호출하면 인수의 개수와 길이가 같은 배열을 만들고 인수들을 만들어진 배열에 저장한 후에 가변인수 메서드에 전달해준다.

#### 53-1. 인수 1개이상

```text
static int min(int firstArg, int... remainingArgs) {
    int min = firstArg;
    for (int arg : remainingArgs) {
        if (arg < min) {
            min = arg;
        }
    }
    return min;
}
```

인수가 1개 이상이어야 할 때는 평범한 매개변수를 추가함으로서, 코드를 깔끔히 만들자.

위와 같이 가변인수는 인수 개수가 정해지지 않았을 때 아주 유용하다.

#### 53-2. 다중정의 활용

성능에 민감한 상황이라면 가변인수가 걸림돌이 될 수 있다.(호출될 때마다 배열 할당 및 초기화)

```text
public void foo() {}
public void foo(int arg1) {}
public void foo(int arg1, arg2) {}
public void foo(int arg1, arg2, arg3) {}
public void foo(int arg1, arg2, arg3, int... restArg) {}
```

위와 같이 다중정의를 사용하면 성능이슈를 최대한 줄일 수 있다.

> 결론: 인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다. 메서드를 정의할 대 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려하자.
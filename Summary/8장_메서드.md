## 8장 메서드

이번 장의 내용 중 상당부분은 메서드뿐 아니라 생성자에도 적용된다.

### 아이템49 - 매개변수가 유효한지 검사하라

___
매개변수 검사를 제대로 하지 못하는 경우 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다. 더 나쁜 상황은 메서드가 잘 수행되지만 잘못된 결과를 반환할 때다. 더더욱 나쁜 상황은 메서드는 문제없이
수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼 때다.

#### 49-1. 문서화

`public`과 `protected` 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.(`@throws` 자바독 태그 사용) 클래스 수준 주석은 그 클래스의 모든 public 메서드에 적용되므로
각 메서드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다.

✔ `@Nullable`이나 이와 비슷한 애너테이션을 사용해 특정 매개변수는 null이 될 수 있다고 알려줄 수도 있지만, 표준적인 방법은 아니다.

#### 49-2. 유효성검사 방법

1. 자바 7에 추가된 `java.util.Objects.requireNonNull`

```text
this.strategy=Objects.requireNonNull(strategy,"전략");
```

더이상 null 검사를 수동으로 하지 않아도 되며, 유연하다.

2. 자바 9에서 추가된 `Objects`에 범위 검사 기능

`checkFromIndexSize`, `checkFromToIndex`, `checkIndex` 라는 메서드인데 null 검사 메서드만큼 유연하지는 않다. 예외 메시지를 지정할 수 없고 리스트와 배열 전용으로
설계됐다. 또한, 닫힌 범위(양 끝단 값을 포함하는)는 다루지 못한다.

3. `assert`

공개되지 않은 메서드(`private`)라면 개발자가 직접 호출되는 상황을 통제할 수 있다. 따라서 오직 유효한 값만이 메서드에 넘겨지리라는 것을 여러분이 보증할 수 있고, 그렇게 해야 한다. 즉, 이럴
때는 `assert`를 사용하여 매개변수 유효성을 검사할 수 있다.

```text
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >=0 && offset <= a.length;
    ...// 계산수행
}
```

여기서 핵심은 위의 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다.

단언문은 몇 가지 면에서 일반적인 유효성 검사와 다르다.

- 실패하면 `AssertionError`를 던진다.
- 런타임에 아무런 효과도, 아무런 성능 저하도 없다.
    - 단, `-ea`, `--enableassertions` 플래그 설정하면 런타임에 영향을 줌.

#### 49-3. 유효성검사 예외

1. 유효성검사 비용이 지나치게 높을 때
2. 실용적이지 않을 때
3. 계산과정에서 암묵적으로 검사가 수행될 때

✔ 예를 들어, `Collections.sort(List)`처럼 리스트를 정렬할 때는 정렬 과정에서 모든 객체가 상호 비교된다. 만일 비교할 수 없는 타입의 객체가 있으면 `ClassCastException`이
발생할 것이기 때문에 비교하기에 앞서 모든 원소를 검증하는 것은 불필요한 과정이 된다.

> 결론: 아이템49를 "매개변수에 제약을 두는 게 좋다"고 해석해서는 안 된다. 사실은 그 반대다. 메서드는 최대한 범용적으로 설계해야 한다.

### 아이템50 - 적시에 방어적 복사본을 만들라

___
자바는 네이티브(Native) 메서드를 사용하지 않아서 C, C++ 언어에서의 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전하다. 하지만 다른 클래스로부터의 침범을 아무런 노력없이 다
막을 수 있는 건 아니다. 따라서 클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.

#### 50-1. 불변식을 지키지 못하는 경우

```java
public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        }
        this.start = start;
        this.end = end;
    }

    public Date start() {
        return start;
    }

    public Date end() {
        return end;
    }
    // ... 생략
}
```

위 클래스는 불변처럼 보인다. 하지만 Date가 가변이라는 사실을 이용하면 어렵지 않게 불변을 깨뜨릴 수 있다.

다행히 자바8 이후로는 쉽게 해결할 수 있다. Date 대신 불변인 Instant를 사용하자.(혹은 `LocalDateTime`, `ZonedDateTime` 사용) **Date는 낡은 API이니 새로운 코드를
작성할 때는 더 이상 사용하면 안 된다.**
하지만 Date처럼 가변인 낡은 타입을 쓰던 시절이 길어서 예전에 작성된 낡은 코드들을 대처해보자.

#### 50-2. 방어적 복사

위의 Period 인스턴스의 내부를 보호하려면 외부의 공격으로부터 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수를 방어적으로 복사해

```java
public Period(Date start,Date end){
        this.start=new Date(start.getTime());
        this.end=new Date(end.getTime());

        if(start.compareTo(this.end)>0){
        throw new IllegalArgumentException(start+"가 "+end+"보다 늦다.");
        }
        }
```

위와 같이 매개변수의 유효성을 검사하기 전에 복사본을 만들어야 한다. 멀티 스레드(Multi-Thread) 환경이라면 원본 객체의 유효성을 검사한 후에 복사본을 만드는 찰나의 순간에 다른 스레드가 원본 객체를 수정할
가능성이 있기 때문이다.

❗ 이와 같은 공격을 검사시점 / 사용시점(time-of-check / time-of-use) 공격 혹은 TOCTOU 공격이라고 한다.

##### 50-2-1. 방어적 복사에서의 `clone`

매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다. 생성자에서와 다르게 접근자 메서드에서는 clone 메서드를 사용해도 된다. Date 객체가 반환될 것임이
확실하기 때문!

##### 50-2-2. 접근자 메서드

위의 Period 메서드는 접근자(getter) 메서드가 내부의 가변 정보 직접 드러내기 때문에 공격이 가능하다.

```text
    Date start=new Date();
    Date end=new Date();
    Period p=new Period(start,end);
    p.end().setYear(78);
```

이 공격을 막아내려면 **가변 필드의 방어적 복사본을 반환하면 된다.**

```text
public Date start(){
    return new Date(start.getTime());
    }
public Date end(){
    return new Date(end.getTime());
    }
```

방어적 복사는 성능 저하가 있을 수 있고 같은 패키지에 속하는 등의 이유로 클라이언트가 객체의 상태를 변경하지 않는 것이 확실하다면 방어적 복사본을 만들지 않아도 된다. 하지만 이러한 상황이라도 명확히 문서화하는
것이 좋다. 다른 패키지에서 사용한다고 해서 방어적 복사를 항상해야 하는 것도 아니다. 메서드 또는 생성자의 매개변수로 넘기는 행위 자체의 의미가 그 객체의 통제권을 명백히 이전함을 뜻하기도 한다.

> 결론: 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다. 되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다.
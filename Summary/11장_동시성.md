## 11장 동시성

스레드는 여러 활동을 동시에 수행할 수 있게 해준다. 하지만 신중히 프로그래밍 해야 한다.



### 목차

___

[아이템78. 공유 중인 가변 데이터는 동기화해 사용해라](#아이템78-공유-중인-가변-데이터는-동기화해-사용해라)

### 아이템78. 공유 중인 가변 데이터는 동기화해 사용해라

___

`synchronized` 키워드는 해당 메서드나 블록을 한번에 한 스레드식 수행하도록 보장한다.

자바 언어 명세는 스레드가 필드를 읽을 때 항상 '수정이 완전히 반영된' 값을 얻는다고 보장하지만, 한 스레드가 저장한 값이 다른 스레드에게 '보이는가'는 보장하지 않는다. **동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.**



#### 78-1. 다른 스레드를 멈추는 올바른 방법

1. 첫 번째 스레드는 자신의 boolean 필드를 폴리앟면서 그 값이 true가 되면 멈춘다.
2. `Thread.stop`은 데이터가 훼손될 수 있어 deprecated API로 지정되어 있다. 쓰지말자!!

```java
public class StopThread{
    private static boolean stopRequested;
    
    public static void main(String[] args) throws InterruptedException{
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while(!stopRequested)
                i++;
        });
        backgroundThread.start();
        
        TimeUnit.SECONDS.sleep(1);
        stopRequested = true;
    }
}
```

위의 코드는 1초 후에 종료가 되지 않고 영원히 수행된다.

- 원인은 동기화에 있다.

```java
public class StopThread{
    private static boolean stopRequested;
    
    private static synchronized void requestStop(){
        stopRequested = true;
    }
    
    private static synchronized boolean stopRequested(){
        return stopRequested;
    }
    
    public static void main(String[] args) throws InterruptedException{
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while(!stopRequested())
                i++;
        });
        backgroundThread.start();
        
        TimeUnit.SECONDS.sleep(1);
        requestStop();
    }
}
```

위의 코드는 정상적으로 1초 후에 종료된다.

- **쓰기와 읽기 모두 동기화되지 않으면 동작을 보장하지 않는다.**



#### 78-2. `volatile` 한정자

`volatile` 한정자는 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 일게 됨을 보장한다.

```java
public class StopThread{
    private static volatile boolean stopRequested;
    
    public static void main(String[] args) throws InterruptedException{
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while(!stopRequested)
                i++;
        });
        backgroundThread.start();
        
        TimeUnit.SECONDS.sleep(1);
        stopRequested = true;
    }
}
```

`volatile` 한정자는 주의해서 사용해야 한다.

```java
private static volatile int nextSerialNumber = 0;

public static int generateSerialNumber(){
    return nextSerialNumber++;
}
```

위 코드는 동기화 없이는 올바로 작동하지 않는다.

✔ 가변 데이터는 단일 스레드에서만 쓰도록 하자.

> 결론: **여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야 한다.** 동기화 하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할 수도 있다.

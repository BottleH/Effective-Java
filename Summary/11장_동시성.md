## 11장 동시성

스레드는 여러 활동을 동시에 수행할 수 있게 해준다. 하지만 신중히 프로그래밍 해야 한다.



### 목차

___

[아이템78. 공유 중인 가변 데이터는 동기화해 사용해라](#아이템78-공유-중인-가변-데이터는-동기화해-사용해라)

[아이템79. 과도한 동기화는 피하라](#아이템79-과도한-동기화는-피하라)



### 아이템78. 공유 중인 가변 데이터는 동기화해 사용해라

___

`synchronized` 키워드는 해당 메서드나 블록을 한번에 한 스레드식 수행하도록 보장한다.

자바 언어 명세는 스레드가 필드를 읽을 때 항상 '수정이 완전히 반영된' 값을 얻는다고 보장하지만, 한 스레드가 저장한 값이 다른 스레드에게 '보이는가'는 보장하지 않는다. **동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.**



#### 78-1. 다른 스레드를 멈추는 올바른 방법

1. 첫 번째 스레드는 자신의 boolean 필드를 폴리앟면서 그 값이 true가 되면 멈춘다.
2. `Thread.stop`은 데이터가 훼손될 수 있어 deprecated API로 지정되어 있다. 쓰지말자!!

```java
public class StopThread{
    private static boolean stopRequested;
    
    public static void main(String[] args) throws InterruptedException{
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while(!stopRequested)
                i++;
        });
        backgroundThread.start();
        
        TimeUnit.SECONDS.sleep(1);
        stopRequested = true;
    }
}
```

위의 코드는 1초 후에 종료가 되지 않고 영원히 수행된다.

- 원인은 동기화에 있다.

```java
public class StopThread{
    private static boolean stopRequested;
    
    private static synchronized void requestStop(){
        stopRequested = true;
    }
    
    private static synchronized boolean stopRequested(){
        return stopRequested;
    }
    
    public static void main(String[] args) throws InterruptedException{
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while(!stopRequested())
                i++;
        });
        backgroundThread.start();
        
        TimeUnit.SECONDS.sleep(1);
        requestStop();
    }
}
```

위의 코드는 정상적으로 1초 후에 종료된다.

- **쓰기와 읽기 모두 동기화되지 않으면 동작을 보장하지 않는다.**



#### 78-2. `volatile` 한정자

`volatile` 한정자는 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 일게 됨을 보장한다.

```java
public class StopThread{
    private static volatile boolean stopRequested;
    
    public static void main(String[] args) throws InterruptedException{
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while(!stopRequested)
                i++;
        });
        backgroundThread.start();
        
        TimeUnit.SECONDS.sleep(1);
        stopRequested = true;
    }
}
```

`volatile` 한정자는 주의해서 사용해야 한다.

```java
private static volatile int nextSerialNumber = 0;

public static int generateSerialNumber(){
    return nextSerialNumber++;
}
```

위 코드는 동기화 없이는 올바로 작동하지 않는다.

✔ 가변 데이터는 단일 스레드에서만 쓰도록 하자.

> 결론: **여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야 한다.** 동기화 하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할 수도 있다.



### 아이템79. 과도한 동기화는 피하라

___

과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠드리고, 심지어 예측할 수 없는 동작을 낳기도 한다.

**응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.**

- 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출해서도 안 되고, 클라이언트가 넘겨준 함수 객체를 호출해서도 안된다.

- 동기화된 영역을 포함한 클래스 관점에서는 이런 메서드는 모두 **외계인 메서드**이다.



#### 79-1. 외계인 메서드 문제

```java
public class ObservableSet<E> extends ForwardingSet<E> {
    public ObservableSet(Set<E> set) {
        super(set);
    }

    private final List<SetObserver<E>> observers = new ArrayList<>();

    public void addObserver(SetObserver<E> observer) {
        synchronized(observers) {
            observers.add(observer);
        }
    }

    public boolean removeObserver(SetObserver<E> observer) {
        synchronized(observers) {
            return observers.remove(observer);
        }
    }

    private void notifyElementAdded(E element) {
        synchronized(observers) {
            for (SetObserver<E> observer : observers)
                observer.added(this, element);
        }
    }

    @Override
    public boolean add(E element) {
        boolean added = super.add(element);
        if (added)
            notifyElementAdded(element);
        return added;
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        boolean result = false;
        for (E element : c)
            result |= add(element); // notifyElementAdded를 호출한다.
        return result;
    }
}
```

```java
@FunctionalInterface
public interface SetObserver<E> {
    // ObservableSet에 원소가 더해지면 호출된다.
    void added(ObservableSet<E> set, E element);
}
```

집합에 원소가 추가되면 알림을 받는 옵저버 패턴을 사용한 예제 코드이다. 이 코드를 이용해 살펴보자.



1. **예외 발생**

```java
public static void main(String[] args) {
    ObservableSet<Integer> set = new ObservableSet<>(new HashSet<>());
    set.addObserver(new SetObserver<>() {
        public void added(ObservableSet<Integer> s, Integer e) {
            System.out.println(e);
            if (e == 23)
                s.removeObserver(this);
        }
    });

    for (int i = 0; i < 100; i++)
        set.add(i;)
}
```

`ConcurrentModificationException`이 발생한다. 정작 자신이 콜백을 거쳐 되돌아와 수정하는 것까지 막지는 못한다.



2. **쓸데없이 백그라운드 스레드를 사용**

```java
    set.addObserver(new SetObserver<>() {
        public void added(ObservableSet<Integer> s, Integer e) {
            System.out.println(e);
            if (e == 23) {
                ExecutorService exec = Executors.newSingleThreadExecutor();
                try {
                    exec.submit(() -> s.removeObserver(this)).get();
                } catch (ExecutionException | InterruptedException ex) {
                    throw new AssertionError(ex);
                } finally {
                    exec.shutdown();
                }
            }
        }
    });
```

이 프로그램을 실행하면 예외는 나지 않지만 교착상태에 빠진다.

- 백그라운드 스레드가 `s.removeObserver`를 호출하면 관찰자를 잠그려 시도하지만 메인 스레드가 락을 쥐고 있음.
- 메인 스레드는 백그라운드 스레드가 관찰자를 제거하기만을 기다림.



#### 79-2. 예외, 교착상태 해결방법

1. 외계인 메서드를 동기화 블록 바깥으로 옮기기

```java
private void notifyElementAdded(E element) {
    List<SetObserver<E>> snapshot = null;
    synchronized (observers) {
        snapshot = new ArrayList<>(observers);
    }
    for (SetObserver<E> observer : snapshot) {
        observer.added(this, element);
    }
}
```



2. 자바의 동시성 컬렉션 라이브러리의 `CopyOnWriteArrayList` 사용

```java
private final List<SetObserver<E>> observers = new CopyOnWriteArrayList<>();

public void addObserver(SetObserver<E> observer) {
    observers.add(observer);
}

public boolean removeObserver(SetObserver<E> observer) {
    return observers.remove(observer);
}

private void notifyElementAdded(E element) {
    for (SetObserver<E> observer : observers)
        observer.added(this, element);
}
```



#### 79-3. 성능 측면에서의 동기화

과도한 동기화는 병렬로 실행할 기회를 잃고, 모든 코어가 메모리를 일관되게 보기 위한 지연시간이 진짜 비용이다. 

가변 클래스를 작성할 때는

1. 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자.
2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.



> 결론: 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자. 동기화 영역 안에서의 작업은 최소한으로 줄이자.



### 아이템80. 스레드보다는 실행자, 태스크, 스트림을 애용하라

___

#### 80-1. 실행자 프레임워크

`java.util.concurrent` 패키지는 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.

```java
ExecutorService exec = Executors.newSingleThreadExecutor();

exec.execute(runnable);

exec.shutdown();
```



- 특정 태스크가 완료되기를 기다린다.
- 태스크 모음 중 아무것 하나(`invokeAny`) 혹은 모든 태스크(`invokeAll`)가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다.(`awaitTermination`)
- 완료된 태스크들의 결과를 차례로 받는다.(`ExecutorCompletionService`)
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다.(`ScheduledThreadPllExecutor`)



#### 80-2. 스레드풀

`Executors.newCachedThreadPool`은 가벼운 프로그램을 실행하는 서버에 적합하다. 요청받은 태스크를 큐에 쌓지 않고 즉시 스레드에 위임돼 실행된다. 가용한 스레드가 없다면 새로 하나를 생성한다. 서버가 무겁다면 CPU 이용률이 100%로 치닫고 새로운 태스크가 도착할 때마다 다른 스레드를 생성하며 상황이 더욱 악화시킨다. 따라서 무거운 프로덕션 서버에는 `Executors.newFixedThreadPool`을 선택하여 스레드 개수를 고정하는 것이 좋다.



#### 80-3. 태스크

작업 큐를 손수 만들고, 스레드를 직접 다루는 것은 일반적으로 삼가야한다.

- 스레드가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 됨.

반면 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다.

- 작업 단위를 나타내는 핵심 추상 개념이 **태스크**다.

**태스크의 종류**는 `Runnable`과 `Callable`로 나눌 수 있다. `Callable`은 `Runnable`과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다.

자바 7부터 실행자 프레임워크는 포크-조인(fork-join) 태스크를 지원하도록 확장됐다. `ForkJoinTask`의 인스턴스는 작은 하위 태스크로 나뉠 수 있고 `ForkJoinPool`을 구성하는 스레드들이 이 태스크들을 처리하며, 일을 먼저 끝낸 스레드가 다른 스레드의 남은 태스크를 가져와 대신 처리할 수도 있다.이렇게 하여 최대한의 CPU 활용을 뽑아내어 높은 처리량과 낮은 지연시간을 달성한다. 포크-조인 풀을 이용해 만든 **병렬 스트림**을 이용하면 적은 노력으로 그 이점을 얻을 수 있다.

## 8장 메서드

이번 장의 내용 중 상당부분은 메서드뿐 아니라 생성자에도 적용된다.

### 아이템49 - 매개변수가 유효한지 검사하라

___
매개변수 검사를 제대로 하지 못하는 경우 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다. 더 나쁜 상황은 메서드가 잘 수행되지만 잘못된 결과를 반환할 때다. 더더욱 나쁜 상황은 메서드는 문제없이
수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼 때다.

#### 49-1. 문서화

`public`과 `protected` 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.(`@throws` 자바독 태그 사용) 클래스 수준 주석은 그 클래스의 모든 public 메서드에 적용되므로
각 메서드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다.

✔ `@Nullable`이나 이와 비슷한 애너테이션을 사용해 특정 매개변수는 null이 될 수 있다고 알려줄 수도 있지만, 표준적인 방법은 아니다.

#### 49-2. 유효성검사 방법

1. 자바 7에 추가된 `java.util.Objects.requireNonNull`

```text
this.strategy=Objects.requireNonNull(strategy,"전략");
```

더이상 null 검사를 수동으로 하지 않아도 되며, 유연하다.

2. 자바 9에서 추가된 `Objects`에 범위 검사 기능

`checkFromIndexSize`, `checkFromToIndex`, `checkIndex` 라는 메서드인데 null 검사 메서드만큼 유연하지는 않다. 예외 메시지를 지정할 수 없고 리스트와 배열 전용으로
설계됐다. 또한, 닫힌 범위(양 끝단 값을 포함하는)는 다루지 못한다.

3. `assert`

공개되지 않은 메서드(`private`)라면 개발자가 직접 호출되는 상황을 통제할 수 있다. 따라서 오직 유효한 값만이 메서드에 넘겨지리라는 것을 여러분이 보증할 수 있고, 그렇게 해야 한다. 즉, 이럴
때는 `assert`를 사용하여 매개변수 유효성을 검사할 수 있다.

```text
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >=0 && offset <= a.length;
    ...// 계산수행
}
```

여기서 핵심은 위의 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다.

단언문은 몇 가지 면에서 일반적인 유효성 검사와 다르다.

- 실패하면 `AssertionError`를 던진다.
- 런타임에 아무런 효과도, 아무런 성능 저하도 없다.
    - 단, `-ea`, `--enableassertions` 플래그 설정하면 런타임에 영향을 줌.

#### 49-3. 유효성검사 예외

1. 유효성검사 비용이 지나치게 높을 때
2. 실용적이지 않을 때
3. 계산과정에서 암묵적으로 검사가 수행될 때

✔ 예를 들어, `Collections.sort(List)`처럼 리스트를 정렬할 때는 정렬 과정에서 모든 객체가 상호 비교된다. 만일 비교할 수 없는 타입의 객체가 있으면 `ClassCastException`이
발생할 것이기 때문에 비교하기에 앞서 모든 원소를 검증하는 것은 불필요한 과정이 된다.

> 결론: 아이템49를 "매개변수에 제약을 두는 게 좋다"고 해석해서는 안 된다. 사실은 그 반대다. 메서드는 최대한 범용적으로 설계해야 한다.

### 아이템50 - 적시에 방어적 복사본을 만들라

- 클라이언트가 여러분의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.
- 가변 필드를 생성자 매개변수로 받아 클래스 필드에 저장하는 경우 각각을 방어적으로 복사해야 한다.
- Date는 낡은 API이니 새로운 코드를 작성할 때는 더 이상 사용하면 안된다.
- 매개변수의 유효성 검사를 하기 전에 방어적 복사본을 만들고 이 복사본으로 유효성을 검사해야 한다.
- 매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.
- 가변 필드를 반환하는 get 접근자 메서드에서는 가변 필드의 방어적 복사본을 반환하도록 해야 한다.
